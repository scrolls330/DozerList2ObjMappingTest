Mapping source ArrayList<> to target class _derived_ from ArrayList<>

DozerMapper Issue Description:

Use case:
A source root object ("class-a") contains a property that is of type ArrayList<>.
The target root object ("class-b") contains a property that is _derived_ from ArrayList<>. (These target classes are generated by a 3rd party code-generator, so we cannot change this behaviour).

Observation 1): On classes derived from ArrayList<>, Dozer does not "see" any properties.

I made and an attached an example project that demonstrates this behaviour. 

The target class that is derived from ArrayList<> is called:
rms.bean_b.ListWrapper.

Note that this class does not make any use of the derived ArrayList<>, it's job is just to show that properties of a class are not seen by Dozer, if that class is derived by ArrayList<> (or any other java.util.* Collection class).

rms.bean_b.ListWrapper has these methods: getContainedList & setContainedList.

Error message at runtime:
Error: org.dozer.MappingException: No read or write method found for field (listwrapper.containedlist) in class (class rms.bean_b.RootNode)
org.dozer.MappingException: No read or write method found for field (listwrapper.containedlist) in class (class rms.bean_b.RootNode)

But if you simply remove "extends ArrayList<>" from the class definition, the properties are seen by Dozer and the respective setters and getters are called.

Observation 2): Dozer's automatic collection mapping functions are not triggered when mapping an ArrayList<> to a class derived from ArrayList<>. In that case the error message is:

Error: org.dozer.MappingException: Illegal object type for the method 'setListWrapper'. 
 Expected types: 
rms.bean_b.ListWrapper
 Actual types: 
java.util.ArrayList

What we really want to achieve: Copy the source ArrayList to the target object which is derived by ArrayList, using the usual Dozer collection mapping features.

The only way we were able to map an ArrayList to a class derived from ArrayList is by using a configurable custom converter.

At least the behaviour described by Observation 1) I would regard as a bug.
